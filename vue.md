# MVVM理解

`MVVM`是一种软件架构模式，`MVVM` 分为 `Model`、`View`、`ViewModel`：

- `Model`代表数据模型，数据和业务逻辑都在`Model`层中定义；
- `View`代表UI视图，负责数据的展示；
- `ViewModel`负责监听`Model`中数据的改变并且控制视图的更新，处理用户交互操作；

`Model`和`View`并无直接关联，而是通过`ViewModel`来进行联系的，`Model`和`ViewModel`之间有着双向数据绑定的联系。因此当`Model`中的数据改变时会触发`View`层的刷新，`View`中由于用户交互操作而改变的数据也会在`Model`中同步。

# Vue3新特性

**1 .** `Vue2`使用的是`optionsAPI `，`Vue3`使用`composition API`，更好地组织代码，提高代码可维护性

- Vue3 之前使用的是 optionsAPI(选项式API)
- Vue3 使用的是 compositionAPI（组合式API）

**2 .** `Vue3`对`TypeScript`的支持更加友好

- **类型推导 :** 就是在没有明确指出变量的类型时，**`TypeScript`** 编译器会自动推测。

<font color="red">**Vue3 新特性**</font>

1 . `Vue3`使用`Proxy`代理实现了新的响应式系统，比`Vue2`有着更好的性能和更准确的数据变化追踪能力。

**2 . 虚拟 `DOM` - 新算法 (更快 更小)**

**3 .** `Vue2`使用的是`optionsAPI `，`Vue3`使用`composition API`，更好地组织代码，提高代码可维护性

**4 .** **`template`** 模板可以有多个根元素

**5 .** 源码用 **`typescript`** 重写, 有更好的 **类型推导** (类型检测更为严格, 更稳定)

<font color="red">**Composition API**</font>

**`setup`** 函数

**`setup` 中不能使用 `this`**, `this` 指向 `undefined`

```
reactive 
ref 
toRef 
toRefs 
computed 
```



# Vue2和Vue3有哪些区别

[《vue2和vue3的区别整理》](https://blog.csdn.net/qq_51075057/article/details/130679841?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171860563416800215066647%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171860563416800215066647&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-130679841-null-null.142^v100^control&utm_term=Vue2%E5%92%8CVue3%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187)

`Vue2`使用的是`optionsAPI `，`Vue3`使用`composition API`，更好地组织代码，提高代码可维护性

`Vue3`使用`Proxy`代理实现了新的响应式系统，比`Vue2`有着更好的性能和更准确的数据变化追踪能力。

`Vue3`对`TypeScript`的支持更加友好

# SPA理解

SPA（单页应用）是一种前端应用程序的架构模式，它通过在加载应用程序时只加载单个 `HTML` 页面，并通过使用 `JavaScript` 动态地更新页面内容，从而实现无刷新的用户体验。

# SPA和多页面有什么区别

怎么记？从打开页面开始的流程

**页面加载方式**：在多页面应用中，每个页面都是独立的 HTML 文件，每次导航时需要重新加载整个页面。而在 `SPA` 中，初始加载时只加载一个 HTML 页面，后续的导航通过 `JavaScript` 动态地更新页面内容，无需重新加载整个页面。

**代码复用**：`SPA` 通常采用组件化开发的方式，可以在不同的页面中复用组件，提高代码的可维护性和可扩展性。多页面应用的每个页面都是独立的，组件复用的机会较少。

**用户体验**：`SPA` 提供了流畅、快速、无刷新的用户体验，因为页面切换时无需等待整个页面的重新加载，只有需要的数据和资源会被加载，减少了页面刷新的延迟。多页面应用则可能会有页面刷新的延迟，给用户带来较长的等待时间。

**路由管理**：在多页面应用中，页面之间的*导航和路由*由服务器处理，每个页面对应一个不同的 `URL`。而在 `SPA` 中，前端负责管理页面的导航和路由，通过前端路由库（如 `React Router` 或 `Vue Router`）来管理不同路径对应的组件。

**SEO（搜索引擎优化）**：由于多页面应用的每个页面都是独立的 HTML 文件，搜索引擎可以直接索引和抓取每个页面的内容，有利于搜索引擎优化。相比之下，`SPA` 的内容是通过 `JavaScript` 动态生成的，搜索引擎的爬虫可能无法正确地获取和索引页面的内容，需要采取额外的优化措施。

**服务器负载**：`SPA` 只需初始加载时获取 `HTML`、`CSS` 和 `JavaScript` 文件，后续的页面更新和数据获取通常通过 API 请求完成，减轻了服务器的负载。而多页面应用每次导航都需要从服务器获取整个页面的内容。

# SPA优缺点

**优点**

- **响应式交互**：由于 `SPA` 依赖于异步数据加载和前端路由，可以实现实时更新和动态加载内容，使用户可以快速地与应用程序交互。
- **代码复用**：`SPA` 通常采用组件化开发的方式，提高了代码的可维护性和可扩展性。
- **用户体验**：`SPA` 提供了流畅、快速的用户体验，在页面加载后，只有需要的数据和资源会被加载，减少了页面刷新的延迟。
- **服务器负载较低**：由于只有初始页面加载时需要从服务器获取 `HTML`、`CSS` 和 `JavaScript` 文件，减轻了服务器的负载。

**缺点**：

- **首次加载时间**：`SPA` 首次加载时需要下载较大的 `JavaScript` 文件，这可能导致初始加载时间较长。
- **SEO（搜索引擎优化）问题**：由于 `SPA` 的内容是通过 `JavaScript` 动态生成的，搜索引擎的爬虫可能无法正确地获取和索引页面的内容。
- **内存占用**：`SPA` 在用户浏览应用程序时保持单个页面的状态，这可能导致较高的内存占用。
- **安全性**：由于 `SPA` 通常使用 `API` 进行数据获取，因此需要特别注意安全性。

# vue性能优化

# 常用的属性、指令有哪些

**属性**：

- `data`：用于定义组件的初始数据。
- `computed`：用于定义计算属性。
- `methods`：用于定义组件的方法。
- `watch`：用于监听组件的数据变化。
- `components`：用于注册子组件。可以通过 `components` 属性将其他组件注册为当前组件的子组件，从而在模板中使用这些子组件。
- `props`：用于传递数据给子组件

**指令**：

- `v-if`：条件渲染指令，根据表达式的真假来决定是否渲染元素。
- `v-show`：条件显示指令，根据表达式的真假来决定元素的显示和隐藏。
- `v-for`：列表渲染指令，用于根据数据源循环渲染元素列表。
- `v-bind`：属性绑定指令，用于动态绑定元素属性到 `Vue` 实例的数据。
- `v-on`：事件绑定指令，用于监听 `DOM` 事件，并执行对应的 `Vue` 方法。
- `v-model`：双向数据绑定指令，用于在表单元素和 `Vue` 实例的数据之间建立双向绑定关系。
- `v-text`：文本插值指令，用于将数据插入到元素的文本内容中。
- `v-html`：`HTML` 插值指令，用于将数据作为 `HTML` 解析并插入到元素中。

# Computed 和 Watch 的区别

`computed`计算属性，通过对已有的属性值进行计算得到一个新值。它需要依赖于其他的数据，当数据发生变化时，`computed`会自动计算更新。`computed`属性值会被缓存，只有当依赖数据发生变化时才会重新计算，这样可以避免重复计算提高性能。

`watch`用于监听数据的变化，并在变化时执行对应的回调函数。它可以监听单个数据或者数组，和`computed`不同的是`watch`不会有缓存。

# v-if和v-show的区别

`v-if`元素不可见，直接删除DOM，有更高的切换消耗。 `v-show`通过设置`display: none`控制显示隐藏，更高的初始渲染消耗。



# 事件修饰符

- `.stop`阻止冒泡
- `.prevent`阻止默认事件
- `.capture` ：使用事件的捕获模式
- .`self` ：只会触发自己范围内的事件，不包含子元素；
- `.once`：只会触发一次事件

# v-model 是如何实现的，语法糖实际是什么？

Vue 中数据双向绑定是一个指令`v-model`，可以绑定一个响应式数据到视图，同时视图的变化能改变该值。

- **当作用在表单上**：通过`v-bind:value`绑定数据，`v-on:input`来监听数据变化并修改`value`
- **当作用在组件上**：本质上是一个父子通信语法糖，通过`props`和`$emit`实现。

# data为什么是一个函数而不是对象

``data`为一个函数，每个组件都会有自己的私有数据空间，不会干扰其他组件的运行。

因为对象是一个引用类型，如果`data`是一个对象的情况下会造成多个组件共用一个`data`

# router和route的区别

- `$route` 用来获取路由信息，包括`path`、`params`、`query`、`name`等路由信息参数
- `$router` 是路由实例，用来操作路由，包含了路由跳转方法、钩子函数等

# 为什么v-for和v-if不能一起使用

`v-for`比`v-if`优先级更高，一起使用的话每次渲染列表时都要执行一次条件判断，造成不必要的计算，影响性能。

# Vue中key的作用

`key`的作用主要是为了高效的更新虚拟DOM，其原理是`vue`在`patch`过程中通过`key`可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，减少`DOM`操作量，提高性能。

# 为什么不建议用index作为key?

如果将数组下标作为`key`值，那么当列表发生变化时，可能会导致`key`值发生改变，从而引发不必要的组件重新渲染，甚至会导致性能问题。例如，当删除列表中某个元素时，其后面的所有元素的下标都会发生改变，导致`Vue`重新渲染整个列表。

# 路由的hash和history模式的区别（？）

**hash模式** 开发中默认的模式，地址栏URL后携带`#`，后面为路由。 原理是通过`onhashchange()`事件监听`hash`值变化，在页面`hash`值发生变化后，`window`就可以监听到事件改变，并按照规则加载相应的代码。`hash`值变化对应的URL都会被记录下来，这样就能实现浏览器历史页面前进后退。

**history模式** `history`模式中URL没有`#`，这样相对`hash`模式更好看，但是需要后台配置支持。

`history`原理是使用`HTML5 history`提供的`pushState`、`replaceState`两个API，用于浏览器记录历史浏览栈，并且在修改URL时不会触发页面刷新和后台数据请求。

# 如何设置动态路由（？）

- params传参
  - 路由配置： `/index/:id`
  - 路由跳转：`this.$router.push({name: 'index', params: {id: "zs"}});`
  - 路由参数获取：`$route.params.id`
  - 最后形成的路由：`/index/zs`
- query传参
  - 路由配置：`/index`正常的路由配置
  - 路由跳转：`this.$rouetr.push({path: 'index', query:{id: "zs"}});`
  - 路由参数获取：`$route.query.id`
  - 最后形成的路由：`/index?id=zs`

**区别**

- 获取参数方式不一样，一个通过`$route.params`，一个通过 `$route.query`
- 参数的生命周期不一样，`query`参数在URL地址栏中显示不容易丢失，`params`参数不会在地址栏显示，刷新后会消失

# v-html 的原理（？）

会先移除节点下的所有节点，调用`html`方法，通过`addProp`添加`innerHTML`属性，归根结底还是设置`innerHTML`为`v-html`的值。

# 双向数据绑定原理

 

# 生命周期
